## WangRen (2024) — Footnote Validation

**Notes:** [WangRen_2024_notes.md](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md)
**PDF:** [WangRen_2024_1845.pdf](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_1845.pdf)
**Total footnotes:** 35 | **Correct:** 25 | **Minor:** 9 | **Incorrect:** 1

---

### INCORRECT Findings

1. [\[^8\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-8-ca72fa8ea81052bb6a294d12c52a4f1d) — Notes state: "the total client storage needed to reconstruct the entire hint table is O(lambda + m log m), avoiding the linear client storage." The actual quote on p.7 is: "the total client storage needed to reconstruct the entire hint table is O(lambda + m log m), avoiding the linear client storage." However, the notes claim the purpose is "Replace T linear-size permutation arrays with T compact PRP-backed instances, reducing client storage from O(n) to O(n/T * log(n/T) + Q * log(n/T))." The formula given in the notes, O(n/T * log(n/T) + Q * log(n/T)), does not appear in the paper. The paper (Section 1.2, p.7) gives O(lambda + m log m) for the DS storage per instance. The actual total client storage from Theorem 4.1 / Section 4.3 (p.21-22) is O(Qw + Q log n). The notes conflate two different formulas and attribute a non-existent expression to Section 1.2.

### MINOR Issues

- [\[^5\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-5-ca72fa8ea81052bb6a294d12c52a4f1d) — Notes say "Section 3.1 (p.12)" for the formal interface definition. The definition begins on p.12 and the operations are described on p.12, which is correct, but the notes also list DS.Init(m, m') as an operation in the interface table; the PDF defines Init separately as a randomized initialization algorithm, not as one of the three interface operations (Access, Locate, Relocate). Mild structural embellishment.
- [\[^6\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-6-ca72fa8ea81052bb6a294d12c52a4f1d) — Notes say "Lemma 3.16 (p.16) proves identical distributions by induction." The PDF has Lemma 3.16 on p.16, which is correct about the induction proof. However, the notes cite "Experiments 3.1 and 3.2" as being on p.13; Experiment 3.1 is on p.13 but Experiment 3.2 is also on p.13. Minor: the security definition text spanning pp.12-13 is attributed solely to p.13.
- [\[^9\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-9-ca72fa8ea81052bb6a294d12c52a4f1d) — Notes quote: "The keys to the PRPs can be derived pseudorandomly via a PRF from a single master key. The T DS instances will share a global array C." The PDF (p.7) says: "(The keys to the PRPs can be derived pseudorandomly via a PRF from a single master key.) The T DS instances will share a global array C that stores the consumed columns, along with a hash map to allow finding the index of any column in C (i.e., 'invert' C) in constant time." The notes truncate the hash-map detail. Minor omission.
- [\[^10\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-10-ca72fa8ea81052bb6a294d12c52a4f1d) — Notes say "Theorem 3.3 (p.13)" for efficiency bounds. Theorem 3.3 is stated on p.13 (bottom), which is correct. However, the notes paraphrase "Relocate(c) then Locate(e) uses O(1) expected time over c in [m'] \ C and O(1) amortized time." The actual Theorem 3.3 states the Relocate+Locate complexity as "O(1) expected PRP calls in addition to O(1) amortized PRP calls across m calls with distinct c." The notes simplify the amortization scope.
- [\[^12\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-12-ca72fa8ea81052bb6a294d12c52a4f1d) — Notes say "Storage is O(|C| * (log m' + log |C|)) bits (storage formula on p.15)." The PDF (p.15, after Construction 3.4) gives the storage as "O(m log m) bits in total" for the array and hash map when m' = O(m). The notes give a more general formula O(|C| * (log m' + log |C|)) that does not appear verbatim in the PDF; it is a reasonable derivation but not a direct citation.
- [\[^14\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-14-ca72fa8ea81052bb6a294d12c52a4f1d) — Notes quote: "The client stores a key ck_hat, the history of consumed columns Hist, and hints h = (h_0, h_1, ..., h_{m'-1})." The PDF (Construction 4.2, p.18) says the client stores "a key ck_hat, the history of consumed columns Hist, and hints h = (h_0, h_1, ..., h_{m'-1})." This is correct but the notes present ck as "(ck_hat, Hist)" whereas the PDF's Construction 4.2 defines ck' = (ck_hat, Hist) in the Query step, and ck is initially just (ck_hat, Hist) from KeyGen. Minor: the notes elide the distinction between ck and ck' after a query.
- [\[^15\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-15-ca72fa8ea81052bb6a294d12c52a4f1d) — Notes cite "Section 1.2 (p.4-5)." The quoted material is from p.4 (bottom) through p.5 (top). The notes say "a random subset of m positions contains the m database entries in that row" which matches the PDF. Minor: the page range could more precisely be p.4-5 (the paragraph straddles the page break), but p.4-5 is acceptable.
- [\[^21\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-21-ca72fa8ea81052bb6a294d12c52a4f1d) — Notes say: "for each row where an element is moved in DS, the value is XORed onto the parity value for the new column (paraphrase of proof argument)." The PDF's Lemma 4.3 proof (p.19) states the argument in terms of Reconstruct calling Relocate for each data structure and updating h_c. The notes' paraphrase is faithful but the notes describe it as updating h_{r_j} with a[j], whereas the actual Reconstruct step in Construction 4.2 does: "Let c = DS_j.Locate(q[j]), update h_c = h_c XOR a[j]." The variable naming differs slightly (notes use r_j for the relocation destination vs. the PDF reusing c).
- [\[^29\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-29-ca72fa8ea81052bb6a294d12c52a4f1d) — Notes cite "Appendix B.1 (p.28)" and quote: "The lower bound in Theorem B.1 can be extended to the amortized server probes over many PIR queries, using a reduction from [CGHK22]." The actual text is in the paragraph labeled "Amortized server probes" on p.28, which is technically within Section B.1 but serves as the bridge to Theorem B.2. The notes attribute the technique to "Theorem 6.2" from [CGHK22], which the PDF text does reference. Minor: the exact phrasing in the PDF is slightly different -- "The lower bound in Theorem B.1 can be extended to the amortized server probes over many PIR queries, using a reduction from [CGHK22]" is a close but not verbatim match.

### Correct

- [\[^1\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-1-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Section 1.1 (p.2): Theorem 1.1 states "Assuming one-way functions exist." PRF from OWF via [GGM86] and small-domain PRP from PRF via [MR14] are both cited in Section 2.2 (p.11) and Section 1.3 (p.9). Verified.
- [\[^2\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-2-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Lemma 4.4 (p.19) states exactly "Construction 4.2 satisfies the correctness definition of client preprocessing PIR." The proof references Lemma 3.13 and Lemma 4.3 as claimed. Deterministic with no failure probability. Verified.
- [\[^3\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-3-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Section 1.1 (p.3): "w = Omega(log n) is the most natural setting as it takes log n bits to represent the index of a database with n entries." The tight tradeoff condition is accurately stated. Verified.
- [\[^4\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-4-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Theorem 1.1 (p.2) lists client storage O(Qw + Q log n), amortized communication O(Tw + T log n), amortized server computation O(T), amortized client computation O(T) XORs and O(T) PRP calls, over Q = n/T queries. All items match. Verified.
- [\[^7\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-7-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Lemma 3.13 (p.15): elements appear once and only once. Lemma 3.14 (p.16): Access and Locate are inverses. Lemma 3.15 (p.16): Relocate moves elements to empty, unconsumed positions. All page numbers and statements verified.
- [\[^11\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-11-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Definition 3.6 (p.15) defines the helper graph G with m' nodes and directed edges from C[t] to P(m+t). Corollary 3.10 confirms disjoint chains and cycles. The description of Locate and Access traversals matches. Verified.
- [\[^13\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-13-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Construction 4.2 (p.18) states DS_j is instantiated with PRP(ck_j, .) where ck_j = PRF(ck_hat, j) and the globally shared Hist. Verified.
- [\[^16\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-16-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Construction 4.2 HintConstruct (p.18) shows "Update h_c = h_c XOR DB_j[e], where c = DS_j.Locate(e)." Verified.
- [\[^17\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-17-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Section 1.2 (p.5): "A consumed column will not be replenished as in all previous schemes, and the hint table now has one fewer column. Naturally, a hint table can only support a limited number of queries." Verified.
- [\[^18\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-18-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Section 1.2 (p.3): DB is divided into T rows of size m = n/T with DB_j = DB[j*m : (j+1)*m]. The notes use the notation from the technical overview. Verified.
- [\[^19\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-19-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Construction 4.2 Query step (p.18): "Let j* <- floor(i/m) and c <- DS_{j*}.Locate(i mod m)." Verified.
- [\[^20\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-20-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Section 4.3 (p.21): Lemma 4.9 proof states the preprocessing step is O(nw) per m = n/T queries and the amortized communication cost from preprocessing is O(Tw). Verified.
- [\[^22\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-22-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Lemma 4.9 / Section 4.3 (p.21): "each online query has communication cost O(Tw + T log n). The client performs the O(nw) preprocessing step per m = n/T queries, so the amortized communication cost from preprocessing is O(Tw) and overall amortized communication cost is O(Tw + T log n) bits." Verified.
- [\[^23\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-23-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Section 4.3 (p.21-22): "h contains m' XOR sums of size w each and has size m'w = O(Qw). ck contains lambda bits of PRF key and the state for Hist... the size of ck is O(Q log n) bits and the total client storage is O(Qw + Q log n) bits." Verified.
- [\[^24\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-24-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Construction 4.2 HintConstruct (p.18): "The client streams the database by each element." Single-pass streaming confirmed. Verified.
- [\[^25\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-25-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Theorem 4.1 (p.17) and Theorem 1.1 (p.2) establish S*T = O(nw) when w = Omega(log n). The derivation S*T = O((n/T)(w + log n)) * T = O(n(w + log n)) = O(nw) is correct. Verified.
- [\[^26\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-26-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Theorem B.1 (p.27) states the bound for l = O(1) servers, computationally secure against single compromised server, with error probability at most 1/15, yielding ST = Omega(nw). Verified.
- [\[^27\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-27-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Appendix B.1 (p.27-28): "setting the entry size to w-bits, the encoded database will have nw bits instead of n bits. For a fixed number of probes, this will allow us to increase the client storage size by w times and still be able to derive the contradiction." Verified.
- [\[^28\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-28-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Theorem B.2 (p.28) states the amortized multi-query bound ST = Omega(nw) for many adaptive queries with at most S bits stored between queries. Verified.
- [\[^30\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-30-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Theorem B.3 (p.28): "Any database-oblivious client preprocessing PIR scheme with S bits of client storage, and a consecutive sequence of 3S/w queries consume less than nw/3 bandwidth, implies an average-case hard promise problem in SZK." Verified.
- [\[^31\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-31-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Appendix B.2 (p.28-29): "The original barrier immediately generalizes to the w-bit entry case as their proof actually proves a barrier for any scheme that can retrieve a single entry of 3S bits from a database of n/3S entries." Verified.
- [\[^32\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-32-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Theorem B.4 (p.29): "Any database-oblivious client preprocessing PIR scheme with S bits of storage, (worst case) online communication cost of less than 1/9 * nw^2/S bits, and amortized communication of less than 1/18 * nw^2/S implies an average-case hard promise problem in SZK." Verified.
- [\[^33\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-33-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Section 1.1 (p.3): "The server performs no extra computation aside from retrieving the T entries requested by the client." Verified.
- [\[^34\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-34-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Section 4.3 (p.22): "Our scheme additionally supports efficient updates to the database, where updating a random database entry takes O(1) expected PRP calls and two XORs." Verified.
- [\[^35\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/wangren_2024/WangRen_2024_notes.md#user-content-fn-35-ca72fa8ea81052bb6a294d12c52a4f1d) — Correct. Appendix A.2 (p.27): "At the beginning of the protocol, the client chooses a PRP P: [n] -> [n] over domain [n] of database indices and sends the PRP key to the server... For every query, the client uses permutation P to transform the desired index into the index of the same entry in the permuted database." Verified.
