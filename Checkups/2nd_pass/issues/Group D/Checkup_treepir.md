## TreePIR (2023) — Footnote Validation

**Notes:** [TreePIR_2023_notes.md](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md)
**PDF:** [TreePIR_2023_204.pdf](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_204.pdf)
**Total footnotes:** 47 | **Correct:** 34 | **Minor:** 10 | **Incorrect:** 3

---

### INCORRECT Findings

1. [\[^7\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-7-aff9086338cab781a5a149e6eda8b217) — Claims "Figure 5 (p.13)" and says "PEval reconstructs the tree by placing the punctured key's seeds into positions as if j were the punctured point." Figure 5 on p.13 shows the wpPRF construction. The PEval algorithm in Figure 5 is described as: "Let y <- G_x((j, k_i)). We denote with G_x((j,k_i)) the leaf node at position x of the tree reconstructed from (j,k_i)." The footnote's description of "placing seeds into positions as if j were the punctured point" is the notes' interpretive gloss, not what Figure 5 says. More importantly, the footnote claims Puncture "outputs the list of seeds not on the path to i, ordered left to right (as shown in Figure 3)." Figure 3 (p.10) shows puncturing a standard GGM PRF, not the wpPRF. The wpPRF Puncture in Figure 5 (p.13) says "Output list of seeds not in path to i, ordered left to right, as shown in Figure 3." So while Figure 3 is referenced by Figure 5, the footnote attributes the construction visual to Figure 5 when the tree diagram is actually Figure 3. The substantive error is that the footnote's interface table (parent context) describes PEval as taking four arguments `PEval(k_i, j, x) -> y`, but the PDF's Definition 3.1 and Figure 5 define PEval as `PEval(k_i, j, x) -> y` with three arguments (matching), so that part is fine. However, the footnote's claim that "PEval reconstructs the tree by placing the punctured key's seeds into positions as if j were the punctured point" mischaracterizes the algorithm -- PEval does not "place seeds into positions"; it reconstructs the full tree from the pair (j, k_i) and reads off the leaf at position x. The actual operation is tree reconstruction from the tuple (j, k_i), not seed placement.

2. [\[^13\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-13-aff9086338cab781a5a149e6eda8b217) — Claims "Section 3 (p.9)." The footnote states: "Standard GGM pPRF punctured key = (x, [sibling seeds]). The index x is explicitly included." Section 3 starts on p.9, but the actual discussion of standard pPRF punctured key structure is on pp.9-10. The substantive problem: the footnote says "Even without x, the structure reveals which subtree x is in." The paper on p.9 says: "although the punctured key k_x of a pPRF P reveals nothing about P.Eval(k,x), it still reveals the punctured point, x. In fact, without revealing x, there is no way to evaluate the pPRF punctured key at the other points." The paper does NOT say the key structure "reveals which subtree x is in" -- it says x is explicitly revealed as part of the key and is needed for evaluation. The notes' claim about structural revelation of the subtree conflates two things: (a) the standard pPRF key includes x explicitly (paper's point), and (b) even if x were removed, the ordered seeds would reveal the subtree (an inference by the notes author, not stated in the paper at this location). The paper's actual concern on p.9 is that x must be included for correctness, not that the structure leaks subtree information.

3. [\[^29\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-29-aff9086338cab781a5a149e6eda8b217) — Marked "Inferred" and claims "~2 KB (at N = 2^32)" for query size. The calculation given is "32 * 128 / 8 = 512 bytes per server, so ~1 KB total." But the table row says "~2 KB (at N = 2^32)" while the footnote's own calculation yields ~1 KB total, creating an internal inconsistency. Furthermore, the paper does not state a concrete query size at N = 2^32; this is purely inferred. The mismatch between the table value (~2 KB) and the footnote's derivation (~1 KB) is a factual error within the notes themselves.

### MINOR Issues

- [\[^1\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-1-aff9086338cab781a5a149e6eda8b217) — Cites "Section 2.1 (p.6)." Definition 2.2 (PIR privacy) is on p.6, confirmed. The footnote says "The adversary controls one server and interacts with a simulator for the other." The actual definition has the adversary interacting with A who acts as one server, while Sim replaces the client -- the adversary does not "interact with a simulator for the other server." Minor inaccuracy in paraphrase.
- [\[^5\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-5-aff9086338cab781a5a149e6eda8b217) — Cites "Figure 1 (p.4)." Confirmed. The footnote says TreePIR achieves "O(sqrt(N) log N) client storage" for the OWF variant. Figure 1 shows O(sqrt(N) log N) client storage for TreePIR Theorem 4.1 -- correct. However, the footnote says "The Shi et al. scheme has the big-O notation hiding very large security-parameter-dependent factors." The paper's footnote beta on Figure 1 says "The big O notation hides factors very large in the security parameter for this scheme" -- the notes reword this adequately but "security-parameter-dependent" is a slight paraphrase.
- [\[^6\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-6-aff9086338cab781a5a149e6eda8b217) — Cites "Section 4.1-4.2 (pp.14-18)." The description says "Puncturing at position x^l (the chunk identifier) produces a key that allows computing parities of the set minus the target element." In the paper, puncturing is at position x^l (the left half / chunk index), which is correct. However the footnote says the set contains "exactly one element per chunk of size sqrt(N)" -- the paper on p.15 says "exactly one element for each interval of size sqrt(N) within [N]," using "interval" not "chunk." Minor terminology difference.
- [\[^8\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-8-aff9086338cab781a5a149e6eda8b217) — Cites "Definition 3.2 (p.12)." Confirmed. The footnote says "Privacy holds because the punctured key is just an ordered array of log(N) random-looking strings (PRG security), independent of which point was punctured." This reasoning is from the proof of Theorem 3.1 (p.13), not from Definition 3.2 itself. The definition just states the game; the justification is from the proof. Minor attribution shift.
- [\[^12\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-12-aff9086338cab781a5a149e6eda8b217) — Cites "Section 3.1, proof of Theorem 3.1 (p.14)." The enumeration time formula is confirmed on p.14: sum_{h=1}^{n} (2^n/2^h) * 2^h = n * 2^n = N log N. However, the total is stated as "2N log N" steps on p.14 ("this whole process of evaluating every S_j takes time 2N log N"), while the footnote says "N log N." The first set takes O(N log N) and the incremental transitions also take N log N in total, giving 2N log N. The notes drop the constant 2.
- [\[^14\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-14-aff9086338cab781a5a149e6eda8b217) — Cites "Section 4.3 (p.20-21)." The content is on p.21. The footnote says "Dottling et al. single-server PIR scheme" while the paper says "Dottling et al. (CRYPTO 2019)" referenced as [19]. The DDH assumption comes from [16] (the DDH assumption reference) combined with the Dottling et al. scheme. Minor: the footnote says "p.20-21" but Lemma 4.1 is entirely on p.21.
- [\[^18\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-18-aff9086338cab781a5a149e6eda8b217) — Cites "Section 4.1 (p.15)." The footnote says "The set S contains each element in [N] with probability 1/sqrt(N)." The paper on p.15 says "The set S will contain each element in [N] with probability 1/sqrt(N)." Confirmed. But the footnote then says the set "contains exactly one element within each interval of size sqrt(N)." The paper says "will contain exactly one element for each interval of size sqrt(N) within [N]." These match but the notes use "within" differently than the paper's "for each interval ... within [N]." Very minor phrasing.
- [\[^22\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-22-aff9086338cab781a5a149e6eda8b217) — Cites "Section 4.2 (pp.17-19)." The footnote says the simulator "samples a random key k and a random element alpha from [sqrt(N)]." The paper on p.19 defines Sim as: "Run k <- F.Gen(1^lambda). Let alpha be an element sampled uniformly from [sqrt(N)]. Output q_sim <- F.Puncture(k, alpha)." The notes say alpha is from [sqrt(N)] but the paper samples alpha uniformly from [sqrt(N)], which matches. However, the notes describe the simulator outputting "F.Puncture(k, alpha)" while the paper uses q_sim notation. Minor notational simplification.
- [\[^36\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-36-aff9086338cab781a5a149e6eda8b217) — Cites "Figure 8 (p.24)." Confirmed. The footnote says TreePIR+SPIRAL is "slightly slower than Checklist's 140 ms for this specific configuration." The actual times are 150 ms vs. 140 ms, which is indeed slightly slower. The footnote also says "14.4x less bandwidth than PRP-PIR" -- PRP-PIR has 721 KB, TreePIR+SPIRAL has 50 KB, giving 721/50 = 14.42x. Correct. However, the footnote says TreePIR+SPIRAL "has much less client storage than Checklist at larger scales" -- for this specific benchmark both have similar storage (67 MB vs 78 MB). The "much less at larger scales" claim is not from Figure 8 itself but is an extrapolation. Minor editorial addition.
- [\[^45\]](../../../../Schemes/Group%20D%20-%20Client%20Dependent%20Preprocessing/treepir_2023/TreePIR_2023_notes.md#user-content-fn-45-aff9086338cab781a5a149e6eda8b217) — Cites "Appendix A.1 (p.27)." Confirmed. The footnote says "S_i = {v || (F.Eval(k_i, v) XOR s_i) : v in [sqrt(N)]}." The paper on p.27 defines the set as S_i = {v || (F.Eval(k_i, v) XOR s_i) : v in [sqrt(N)]}. Match confirmed. However, the footnote says the shift technique "was previously used in PRP-PIR [15]," while the paper says "this technique was used before in [15]" without calling it "PRP-PIR." Minor labeling addition.
